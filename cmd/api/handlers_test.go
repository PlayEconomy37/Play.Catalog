package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"testing"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

func TestHealthCheckHandler(t *testing.T) {
	app, cleanup := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	statusCode, _, resBody := ts.get(t, "/healthcheck", false, "")

	if statusCode != http.StatusOK {
		t.Errorf("want %d; got %d", http.StatusOK, statusCode)
	}

	if !bytes.Contains(resBody, []byte("available")) {
		t.Errorf("want body %q to contain %q", []byte("available"), resBody)
	}
}

func TestCreateItemHandler(t *testing.T) {
	app, cleanup := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	authenticationTests := []struct {
		testName           string
		useAuthHeader      bool
		accessToken        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No Authorization header", false, "", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Invalid access token", true, "invalid", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Access token not generated by identity microservice", true, invalidAccessToken, http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"User does not have permission - has catalog:read", true, accessTokenUser2, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
		{"User does not have permission - has inventory:read", true, accessTokenUser3, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
	}

	for _, tt := range authenticationTests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["name"] = "Potion"
			body["description"] = "Restores a small amount of health"
			body["price"] = 5

			statusCode, _, resBody := ts.post(t, "/items", body, tt.useAuthHeader, tt.accessToken)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	validationTests := []struct {
		testName           string
		name               string
		description        string
		price              float64
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Valid submission", "Potion", "Restores a small amount of health", 5, http.StatusCreated, []byte("Item created successfully")},
		{"Empty name", "", "Restores a small amount of health", 5, http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Empty description", "Potion", "", 5, http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Invalid price value (below 0.1)", "Potion", "Restores a small amount of health", 0, http.StatusUnprocessableEntity, []byte("must be greater or equal to 0.1 and lower or equal to 1000")},
		{"Invalid price value (above 1000.0)", "Potion", "Restores a small amount of health", 1001, http.StatusUnprocessableEntity, []byte("must be greater or equal to 0.1 and lower or equal to 1000")},
	}

	for _, tt := range validationTests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["name"] = tt.name
			body["description"] = tt.description
			body["price"] = tt.price

			statusCode, _, resBody := ts.post(t, "/items", body, true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	malformedJSONTest := struct {
		testName           string
		name               string
		description        string
		price              string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		"Potion",
		"Restores a small amount of health",
		"invalid",
		http.StatusBadRequest,
		[]byte("body contains incorrect JSON type for field"),
	}

	body := map[string]any{}
	body["name"] = malformedJSONTest.name
	body["description"] = malformedJSONTest.description
	body["price"] = malformedJSONTest.price

	statusCode, _, resBody := ts.post(t, "/items", body, true, accessTokenUser1)

	if statusCode != malformedJSONTest.wantedStatusCode {
		t.Errorf("want %d; got %d", malformedJSONTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, malformedJSONTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, malformedJSONTest.wantedResponseBody)
	}

	// -----------------------------

	unknownKeyTest := struct {
		testName           string
		name               string
		description        string
		invalid            float64
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		"Potion",
		"Restores a small amount of health",
		5,
		http.StatusBadRequest,
		[]byte("body contains unknown key"),
	}

	body = map[string]any{}
	body["name"] = unknownKeyTest.name
	body["description"] = unknownKeyTest.description
	body["invalid"] = unknownKeyTest.invalid

	statusCode, _, resBody = ts.post(t, "/items", body, true, accessTokenUser1)

	if statusCode != unknownKeyTest.wantedStatusCode {
		t.Errorf("want %d; got %d", unknownKeyTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, unknownKeyTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, unknownKeyTest.wantedResponseBody)
	}
}

func TestGetItemsHandler(t *testing.T) {
	app, cleanup := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Seed items collection
	seedItemsCollection(t, app.ItemsRepository)

	authenticationTests := []struct {
		testName           string
		useAuthHeader      bool
		accessToken        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No Authorization header", false, "", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Invalid access token", true, "invalid", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Access token not generated by identity microservice", true, invalidAccessToken, http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"User does not have permission - has inventory:read", true, accessTokenUser3, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
	}

	for _, tt := range authenticationTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, "/items", tt.useAuthHeader, tt.accessToken)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	validationTests := []struct {
		testName           string
		queryString        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Invalid min_price", "?min_price=invalid", http.StatusUnprocessableEntity, []byte("must be a float64 value")},
		{"Invalid max_price", "?max_price=invalid", http.StatusUnprocessableEntity, []byte("must be a float64 value")},
		{"Invalid page", "?page=invalid", http.StatusUnprocessableEntity, []byte("must be an integer value")},
		{"Invalid page_size", "?page_size=invalid", http.StatusUnprocessableEntity, []byte("must be an integer value")},
		{"Invalid sort value", "?sort=invalid", http.StatusUnprocessableEntity, []byte("invalid sort value")},
		{"min_price lower than 0.1", "?min_price=0", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0.1 or lower and equal to 1000")},
		{"min_price greater than 1000", "?min_price=1001", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0.1 or lower and equal to 1000")},
		{"max_price lower than 0.1", "?max_price=0", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0.1 or lower and equal to 1000")},
		{"max_price greater than 1000", "?max_price=1001", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0.1 or lower and equal to 1000")},
		{"page lower than 0", "?page=-1", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 10 million")},
		{"page greater than 10000000", "?page=10000001", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 10 million")},
		{"page_size lower than 0", "?page_size=-1", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 100")},
		{"page_size greater than 100", "?page_size=101", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 100")},
	}

	for _, tt := range validationTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, fmt.Sprintf("/items%s", tt.queryString), true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	successTests := []struct {
		testName             string
		queryString          string
		wantedStatusCode     int
		expectedTotalRecords int
		expectedCurrentPage  int
		expectedLastPage     int
	}{
		{"No filters set", "", http.StatusOK, 5, 1, 1},
		{"name filter", "?name=potion", http.StatusOK, 3, 1, 1},
		{"min_price filter", "?min_price=7", http.StatusOK, 2, 1, 1},
		{"max_price filter", "?max_price=4", http.StatusOK, 1, 1, 1},
		{"min_price and max_price filters", "?min_price=4&max_price=6", http.StatusOK, 2, 1, 1},
		{"name, page and page_size filters (page 1)", "?name=potion&page=1&page_size=2", http.StatusOK, 2, 1, 2},
		{"name, page and page_size filters (page 2)", "?name=potion&page=2&page_size=2", http.StatusOK, 1, 2, 2},
		{"name and sort filters", "?name=potion&sort=-name", http.StatusOK, 3, 1, 1},
	}

	for _, tt := range successTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, fmt.Sprintf("/items%s", tt.queryString), true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			var jsonRes map[string]any

			err := json.Unmarshal(resBody, &jsonRes)
			if err != nil {
				t.Error("Failed to parse json response")
			}

			items := (jsonRes["items"]).([]any)

			if tt.testName == "name and sort filters" {
				item0 := (items[0]).(map[string]any)
				if item0["name"] != "Potion" {
					t.Errorf("want to receive Potion but got %s", item0["name"])
				}

				item1 := (items[1]).(map[string]any)
				if item1["name"] != "Mega Potion" {
					t.Errorf("want to receive Mega Potion but got %s", item1["name"])
				}

				item2 := (items[2]).(map[string]any)
				if item2["name"] != "Hi-Potion" {
					t.Errorf("want to receive Hi-Potion but got %s", item2["name"])
				}
			}

			if len(items) != tt.expectedTotalRecords {
				t.Errorf("want to receive %d items but got %d", tt.expectedTotalRecords, len(items))
			}

			metadata := (jsonRes["metadata"]).(map[string]any)

			if metadata["total_records"] == tt.expectedTotalRecords {
				t.Errorf("want total_records to be %d but got %d", tt.expectedTotalRecords, metadata["total_records"])
			}

			if metadata["current_page"] == tt.expectedCurrentPage {
				t.Errorf("want current_page to be %d but got %d", tt.expectedCurrentPage, metadata["current_page"])
			}

			if metadata["last_page"] == tt.expectedLastPage {
				t.Errorf("want last_page to be %d but got %d", tt.expectedLastPage, metadata["last_page"])
			}
		})
	}
}

func TestGetItemHandler(t *testing.T) {
	app, cleanup := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Create an item and retrieve its id
	itemName := "Potion"
	body := map[string]any{}
	body["name"] = itemName
	body["description"] = "Restores a small amount of health"
	body["price"] = 5

	_, headers, _ := ts.post(t, "/items", body, true, accessTokenUser1)
	itemID := strings.Split(headers.Get("Location"), "/")[2]

	authenticationTests := []struct {
		testName           string
		useAuthHeader      bool
		accessToken        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No Authorization header", false, "", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Invalid access token", true, "invalid", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Access token not generated by identity microservice", true, invalidAccessToken, http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"User does not have permission - has inventory:read", true, accessTokenUser3, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
	}

	for _, tt := range authenticationTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, fmt.Sprintf("/items/%s", itemID), tt.useAuthHeader, tt.accessToken)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	validationTests := []struct {
		testName           string
		id                 string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Invalid id (int)", "5", http.StatusNotFound, []byte("The requested resource could not be found")},
		{"Invalid id (uuid)", "73f4fa2d-f134-4351-a14e-a0f0a8541712", http.StatusNotFound, []byte("The requested resource could not be found")},
		{"Unknown id", primitive.NewObjectID().Hex(), http.StatusNotFound, []byte("The requested resource could not be found")},
	}

	for _, tt := range validationTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, fmt.Sprintf("/items/%s", tt.id), true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	successTest := struct {
		testName         string
		wantedStatusCode int
	}{
		"Valid submission",
		http.StatusOK,
	}

	statusCode, _, resBody := ts.get(t, fmt.Sprintf("/items/%s", itemID), true, accessTokenUser1)

	if statusCode != successTest.wantedStatusCode {
		t.Errorf("want %d; got %d", successTest.wantedStatusCode, statusCode)
	}

	var jsonRes map[string]any

	err := json.Unmarshal(resBody, &jsonRes)
	if err != nil {
		t.Error("Failed to parse json response")
	}

	item := (jsonRes["item"]).(map[string]any)

	if item["name"] != itemName {
		t.Errorf("want to receive %s but got %s", itemName, item["name"])
	}
}

func TestUpdateItemHandler(t *testing.T) {
	app, cleanup := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Create an item and retrieve its id
	name := "Potion"
	body := map[string]any{}
	body["name"] = name
	body["description"] = "Restores a small amount of health"
	body["price"] = 5

	_, headers, _ := ts.post(t, "/items", body, true, accessTokenUser1)
	itemID := strings.Split(headers.Get("Location"), "/")[2]

	// Fetch created item and make sure it exists in database
	createdItem := fetchItem(t, app.ItemsRepository, itemID)

	if createdItem.Name != name {
		t.Errorf("want %s; got %s", name, createdItem.Name)
	}

	authenticationTests := []struct {
		testName           string
		useAuthHeader      bool
		accessToken        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No Authorization header", false, "", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Invalid access token", true, "invalid", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Access token not generated by identity microservice", true, invalidAccessToken, http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"User does not have permission - has catalog:read", true, accessTokenUser2, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
		{"User does not have permission - has inventory:read", true, accessTokenUser3, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
	}

	for _, tt := range authenticationTests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["name"] = "Potion"
			body["description"] = "Restores a small amount of health"
			body["price"] = 5

			statusCode, _, resBody := ts.put(t, fmt.Sprintf("/items/%s", itemID), body, tt.useAuthHeader, tt.accessToken)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	tests := []struct {
		testName           string
		idUrlParam         string
		name               string
		description        string
		price              float64
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Valid submission", itemID, "Potion", "Restores a small amount of health", 7, http.StatusOK, []byte("Item updated successfully")},
		{"Empty name", itemID, "", "Restores a small amount of health", 5, http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Empty description", itemID, "Potion", "", 5, http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Invalid price value (below 0.1)", itemID, "Potion", "Restores a small amount of health", 0, http.StatusUnprocessableEntity, []byte("must be greater or equal to 0.1 and lower or equal to 1000")},
		{"Invalid price value (above 1000.0)", itemID, "Potion", "Restores a small amount of health", 1001, http.StatusUnprocessableEntity, []byte("must be greater or equal to 0.1 and lower or equal to 1000")},
		{"Invalid id URL param (int)", "5", "Potion", "Restores a small amount of health", 5, http.StatusNotFound, []byte("The requested resource could not be found")},
		{"Invalid id URL param (uuid)", "73f4fa2d-f134-4351-a14e-a0f0a8541712", "Potion", "Restores a small amount of health", 5, http.StatusNotFound, []byte("The requested resource could not be found")},
		{"Unknown id URL param", primitive.NewObjectID().Hex(), "Potion", "Restores a small amount of health", 5, http.StatusNotFound, []byte("The requested resource could not be found")},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["name"] = tt.name
			body["description"] = tt.description
			body["price"] = tt.price

			statusCode, _, resBody := ts.put(t, fmt.Sprintf("/items/%s", tt.idUrlParam), body, true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// Fetch item again and make sure it was updated in the database
	updatedItem := fetchItem(t, app.ItemsRepository, itemID)

	if updatedItem.Price != 7 {
		t.Errorf("want %d; got %f", 7, updatedItem.Price)
	}

	if updatedItem.Version != 2 {
		t.Errorf("want %d; got %d", 2, updatedItem.Version)
	}

	// -----------------------------

	malformedJsonTest := struct {
		testName           string
		idUrlParam         string
		name               string
		description        string
		price              string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		itemID,
		"Potion",
		"Restores a small amount of health",
		"invalid",
		http.StatusBadRequest,
		[]byte("body contains incorrect JSON type for field"),
	}

	body = map[string]any{}
	body["name"] = malformedJsonTest.name
	body["description"] = malformedJsonTest.description
	body["price"] = malformedJsonTest.price

	statusCode, _, resBody := ts.put(t, fmt.Sprintf("/items/%s", malformedJsonTest.idUrlParam), body, true, accessTokenUser1)

	if statusCode != malformedJsonTest.wantedStatusCode {
		t.Errorf("want %d; got %d", malformedJsonTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, malformedJsonTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, malformedJsonTest.wantedResponseBody)
	}

	// -----------------------------

	unknownKeyTest := struct {
		testName           string
		idUrlParam         string
		name               string
		description        string
		invalid            float64
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		itemID,
		"Potion",
		"Restores a small amount of health",
		5,
		http.StatusBadRequest,
		[]byte("body contains unknown key"),
	}

	body = map[string]any{}
	body["name"] = unknownKeyTest.name
	body["description"] = unknownKeyTest.description
	body["invalid"] = unknownKeyTest.invalid

	statusCode, _, resBody = ts.put(t, fmt.Sprintf("/items/%s", unknownKeyTest.idUrlParam), body, true, accessTokenUser1)

	if statusCode != unknownKeyTest.wantedStatusCode {
		t.Errorf("want %d; got %d", unknownKeyTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, unknownKeyTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, unknownKeyTest.wantedResponseBody)
	}
}

func TestDeleteItemHandler(t *testing.T) {
	app, cleanup := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Create an item and retrieve its id
	name := "Potion"
	body := map[string]any{}
	body["name"] = name
	body["description"] = "Restores a small amount of health"
	body["price"] = 5

	_, headers, _ := ts.post(t, "/items", body, true, accessTokenUser1)
	itemID := strings.Split(headers.Get("Location"), "/")[2]

	// Fetch created item and make sure it exists in database
	createdItem := fetchItem(t, app.ItemsRepository, itemID)

	if createdItem.Name != name {
		t.Errorf("want %s; got %s", name, createdItem.Name)
	}

	authenticationTests := []struct {
		testName           string
		useAuthHeader      bool
		accessToken        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No Authorization header", false, "", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Invalid access token", true, "invalid", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Access token not generated by identity microservice", true, invalidAccessToken, http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"User does not have permission - has catalog:read", true, accessTokenUser2, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
		{"User does not have permission - has inventory:read", true, accessTokenUser3, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
	}

	for _, tt := range authenticationTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.delete(t, fmt.Sprintf("/items/%s", itemID), tt.useAuthHeader, tt.accessToken)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	tests := []struct {
		testName           string
		id                 string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Valid submission", itemID, http.StatusOK, []byte("Item deleted successfully")},
		{"Invalid id (int)", "5", http.StatusNotFound, []byte("The requested resource could not be found")},
		{"Invalid id (uuid)", "73f4fa2d-f134-4351-a14e-a0f0a8541712", http.StatusNotFound, []byte("The requested resource could not be found")},
		{"Unknown id", primitive.NewObjectID().Hex(), http.StatusNotFound, []byte("The requested resource could not be found")},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.delete(t, fmt.Sprintf("/items/%s", tt.id), true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// Try to fetch item again and make sure it does not exist in the database
	item := fetchItem(t, app.ItemsRepository, itemID)

	// Zero value of name field
	if item.Name != "" {
		t.Errorf("want %s; got %s", "name", item.Name)
	}
}
